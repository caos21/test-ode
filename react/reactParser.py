# Generated from react.g4 by ANTLR 4.6
# encoding: utf-8
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3\16")
        buf.write("\u008a\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\6\2(\n\2\r\2\16\2)\3\3\3\3\3\3\3\3\5\3\60\n\3\5\3")
        buf.write("\62\n\3\3\3\3\3\5\3\66\n\3\3\4\3\4\3\4\3\4\5\4<\n\4\3")
        buf.write("\4\5\4?\n\4\3\4\5\4B\n\4\3\4\3\4\7\4F\n\4\f\4\16\4I\13")
        buf.write("\4\5\4K\n\4\3\5\3\5\3\5\3\5\3\5\5\5R\n\5\3\6\3\6\3\7\3")
        buf.write("\7\3\b\3\b\3\t\3\t\3\n\3\n\3\13\3\13\3\13\3\13\7\13b\n")
        buf.write("\13\f\13\16\13e\13\13\3\f\5\fh\n\f\3\f\3\f\3\r\3\r\3\r")
        buf.write("\3\r\7\rp\n\r\f\r\16\rs\13\r\3\16\5\16v\n\16\3\16\3\16")
        buf.write("\3\17\3\17\3\20\3\20\3\20\5\20\177\n\20\3\21\3\21\3\22")
        buf.write("\3\22\3\23\5\23\u0086\n\23\3\23\3\23\3\23\2\2\24\2\4\6")
        buf.write("\b\n\f\16\20\22\24\26\30\32\34\36 \"$\2\3\3\2\7\b\u0087")
        buf.write("\2\'\3\2\2\2\4\65\3\2\2\2\6\67\3\2\2\2\bL\3\2\2\2\nS\3")
        buf.write("\2\2\2\fU\3\2\2\2\16W\3\2\2\2\20Y\3\2\2\2\22[\3\2\2\2")
        buf.write("\24]\3\2\2\2\26g\3\2\2\2\30k\3\2\2\2\32u\3\2\2\2\34y\3")
        buf.write("\2\2\2\36{\3\2\2\2 \u0080\3\2\2\2\"\u0082\3\2\2\2$\u0085")
        buf.write("\3\2\2\2&(\5\4\3\2\'&\3\2\2\2()\3\2\2\2)\'\3\2\2\2)*\3")
        buf.write("\2\2\2*\3\3\2\2\2+\66\7\3\2\2,\62\5\36\20\2-\60\5\b\5")
        buf.write("\2.\60\5\6\4\2/-\3\2\2\2/.\3\2\2\2\60\62\3\2\2\2\61,\3")
        buf.write("\2\2\2\61/\3\2\2\2\62\63\3\2\2\2\63\64\7\4\2\2\64\66\3")
        buf.write("\2\2\2\65+\3\2\2\2\65\61\3\2\2\2\66\5\3\2\2\2\678\5\30")
        buf.write("\r\289\7\13\2\29;\5\24\13\2:<\5\22\n\2;:\3\2\2\2;<\3\2")
        buf.write("\2\2<>\3\2\2\2=?\5\20\t\2>=\3\2\2\2>?\3\2\2\2?A\3\2\2")
        buf.write("\2@B\5\16\b\2A@\3\2\2\2AB\3\2\2\2BJ\3\2\2\2CG\5\f\7\2")
        buf.write("DF\5$\23\2ED\3\2\2\2FI\3\2\2\2GE\3\2\2\2GH\3\2\2\2HK\3")
        buf.write("\2\2\2IG\3\2\2\2JC\3\2\2\2JK\3\2\2\2K\7\3\2\2\2LM\7\t")
        buf.write("\2\2MN\5 \21\2NQ\7\n\2\2OP\7\f\2\2PR\5\n\6\2QO\3\2\2\2")
        buf.write("QR\3\2\2\2R\t\3\2\2\2ST\5$\23\2T\13\3\2\2\2UV\5$\23\2")
        buf.write("V\r\3\2\2\2WX\5$\23\2X\17\3\2\2\2YZ\5$\23\2Z\21\3\2\2")
        buf.write("\2[\\\5 \21\2\\\23\3\2\2\2]c\5\26\f\2^_\5\"\22\2_`\5\26")
        buf.write("\f\2`b\3\2\2\2a^\3\2\2\2be\3\2\2\2ca\3\2\2\2cd\3\2\2\2")
        buf.write("d\25\3\2\2\2ec\3\2\2\2fh\5$\23\2gf\3\2\2\2gh\3\2\2\2h")
        buf.write("i\3\2\2\2ij\5 \21\2j\27\3\2\2\2kq\5\32\16\2lm\5\"\22\2")
        buf.write("mn\5\32\16\2np\3\2\2\2ol\3\2\2\2ps\3\2\2\2qo\3\2\2\2q")
        buf.write("r\3\2\2\2r\31\3\2\2\2sq\3\2\2\2tv\5$\23\2ut\3\2\2\2uv")
        buf.write("\3\2\2\2vw\3\2\2\2wx\5 \21\2x\33\3\2\2\2yz\5$\23\2z\35")
        buf.write("\3\2\2\2{~\5 \21\2|}\7\f\2\2}\177\5\34\17\2~|\3\2\2\2")
        buf.write("~\177\3\2\2\2\177\37\3\2\2\2\u0080\u0081\7\5\2\2\u0081")
        buf.write("!\3\2\2\2\u0082\u0083\7\7\2\2\u0083#\3\2\2\2\u0084\u0086")
        buf.write("\t\2\2\2\u0085\u0084\3\2\2\2\u0085\u0086\3\2\2\2\u0086")
        buf.write("\u0087\3\2\2\2\u0087\u0088\7\6\2\2\u0088%\3\2\2\2\22)")
        buf.write("/\61\65;>AGJQcgqu~\u0085")
        return buf.getvalue()


class reactParser ( Parser ):

    grammarFileName = "react.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "';'", "<INVALID>", "<INVALID>", 
                     "'+'", "'-'", "'D['", "']'", "'->'", "'='", "'.'" ]

    symbolicNames = [ "<INVALID>", "COMMENT", "SEMICOLON", "SYMBOL", "SCIENTIFIC_NUMBER", 
                      "PLUS", "MINUS", "LDIFFBRACKET", "RBRACKET", "PRODUCE", 
                      "EQUAL", "POINT", "WHITESPACE" ]

    RULE_entries = 0
    RULE_entry = 1
    RULE_reaction = 2
    RULE_diffusion = 3
    RULE_dvalue = 4
    RULE_beta = 5
    RULE_eactivation = 6
    RULE_aconstant = 7
    RULE_rate = 8
    RULE_products = 9
    RULE_product = 10
    RULE_reactants = 11
    RULE_reactant = 12
    RULE_cvalue = 13
    RULE_constant = 14
    RULE_symbol = 15
    RULE_combineOperator = 16
    RULE_scientific = 17

    ruleNames =  [ "entries", "entry", "reaction", "diffusion", "dvalue", 
                   "beta", "eactivation", "aconstant", "rate", "products", 
                   "product", "reactants", "reactant", "cvalue", "constant", 
                   "symbol", "combineOperator", "scientific" ]

    EOF = Token.EOF
    COMMENT=1
    SEMICOLON=2
    SYMBOL=3
    SCIENTIFIC_NUMBER=4
    PLUS=5
    MINUS=6
    LDIFFBRACKET=7
    RBRACKET=8
    PRODUCE=9
    EQUAL=10
    POINT=11
    WHITESPACE=12

    def __init__(self, input:TokenStream):
        super().__init__(input)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class EntriesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(reactParser.EntryContext)
            else:
                return self.getTypedRuleContext(reactParser.EntryContext,i)


        def getRuleIndex(self):
            return reactParser.RULE_entries

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntries" ):
                return visitor.visitEntries(self)
            else:
                return visitor.visitChildren(self)




    def entries(self):

        localctx = reactParser.EntriesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_entries)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 36
                self.entry()
                self.state = 39 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << reactParser.COMMENT) | (1 << reactParser.SYMBOL) | (1 << reactParser.SCIENTIFIC_NUMBER) | (1 << reactParser.PLUS) | (1 << reactParser.MINUS) | (1 << reactParser.LDIFFBRACKET))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EntryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(reactParser.COMMENT, 0)

        def SEMICOLON(self):
            return self.getToken(reactParser.SEMICOLON, 0)

        def constant(self):
            return self.getTypedRuleContext(reactParser.ConstantContext,0)


        def diffusion(self):
            return self.getTypedRuleContext(reactParser.DiffusionContext,0)


        def reaction(self):
            return self.getTypedRuleContext(reactParser.ReactionContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_entry

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntry" ):
                return visitor.visitEntry(self)
            else:
                return visitor.visitChildren(self)




    def entry(self):

        localctx = reactParser.EntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_entry)
        try:
            self.state = 51
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [reactParser.COMMENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 41
                self.match(reactParser.COMMENT)
                pass
            elif token in [reactParser.SYMBOL, reactParser.SCIENTIFIC_NUMBER, reactParser.PLUS, reactParser.MINUS, reactParser.LDIFFBRACKET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 47
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                if la_ == 1:
                    self.state = 42
                    self.constant()
                    pass

                elif la_ == 2:
                    self.state = 45
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [reactParser.LDIFFBRACKET]:
                        self.state = 43
                        self.diffusion()
                        pass
                    elif token in [reactParser.SYMBOL, reactParser.SCIENTIFIC_NUMBER, reactParser.PLUS, reactParser.MINUS]:
                        self.state = 44
                        self.reaction()
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass


                self.state = 49
                self.match(reactParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReactionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def reactants(self):
            return self.getTypedRuleContext(reactParser.ReactantsContext,0)


        def PRODUCE(self):
            return self.getToken(reactParser.PRODUCE, 0)

        def products(self):
            return self.getTypedRuleContext(reactParser.ProductsContext,0)


        def rate(self):
            return self.getTypedRuleContext(reactParser.RateContext,0)


        def aconstant(self):
            return self.getTypedRuleContext(reactParser.AconstantContext,0)


        def eactivation(self):
            return self.getTypedRuleContext(reactParser.EactivationContext,0)


        def beta(self):
            return self.getTypedRuleContext(reactParser.BetaContext,0)


        def scientific(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(reactParser.ScientificContext)
            else:
                return self.getTypedRuleContext(reactParser.ScientificContext,i)


        def getRuleIndex(self):
            return reactParser.RULE_reaction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReaction" ):
                return visitor.visitReaction(self)
            else:
                return visitor.visitChildren(self)




    def reaction(self):

        localctx = reactParser.ReactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_reaction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.reactants()
            self.state = 54
            self.match(reactParser.PRODUCE)
            self.state = 55
            self.products()
            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==reactParser.SYMBOL:
                self.state = 56
                self.rate()


            self.state = 60
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 59
                self.aconstant()


            self.state = 63
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.state = 62
                self.eactivation()


            self.state = 72
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << reactParser.SCIENTIFIC_NUMBER) | (1 << reactParser.PLUS) | (1 << reactParser.MINUS))) != 0):
                self.state = 65
                self.beta()
                self.state = 69
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << reactParser.SCIENTIFIC_NUMBER) | (1 << reactParser.PLUS) | (1 << reactParser.MINUS))) != 0):
                    self.state = 66
                    self.scientific()
                    self.state = 71
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DiffusionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LDIFFBRACKET(self):
            return self.getToken(reactParser.LDIFFBRACKET, 0)

        def symbol(self):
            return self.getTypedRuleContext(reactParser.SymbolContext,0)


        def RBRACKET(self):
            return self.getToken(reactParser.RBRACKET, 0)

        def EQUAL(self):
            return self.getToken(reactParser.EQUAL, 0)

        def dvalue(self):
            return self.getTypedRuleContext(reactParser.DvalueContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_diffusion

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiffusion" ):
                return visitor.visitDiffusion(self)
            else:
                return visitor.visitChildren(self)




    def diffusion(self):

        localctx = reactParser.DiffusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_diffusion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.match(reactParser.LDIFFBRACKET)
            self.state = 75
            self.symbol()
            self.state = 76
            self.match(reactParser.RBRACKET)
            self.state = 79
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==reactParser.EQUAL:
                self.state = 77
                self.match(reactParser.EQUAL)
                self.state = 78
                self.dvalue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DvalueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scientific(self):
            return self.getTypedRuleContext(reactParser.ScientificContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_dvalue

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDvalue" ):
                return visitor.visitDvalue(self)
            else:
                return visitor.visitChildren(self)




    def dvalue(self):

        localctx = reactParser.DvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_dvalue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.scientific()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BetaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scientific(self):
            return self.getTypedRuleContext(reactParser.ScientificContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_beta

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeta" ):
                return visitor.visitBeta(self)
            else:
                return visitor.visitChildren(self)




    def beta(self):

        localctx = reactParser.BetaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_beta)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.scientific()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EactivationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scientific(self):
            return self.getTypedRuleContext(reactParser.ScientificContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_eactivation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEactivation" ):
                return visitor.visitEactivation(self)
            else:
                return visitor.visitChildren(self)




    def eactivation(self):

        localctx = reactParser.EactivationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_eactivation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self.scientific()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AconstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scientific(self):
            return self.getTypedRuleContext(reactParser.ScientificContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_aconstant

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAconstant" ):
                return visitor.visitAconstant(self)
            else:
                return visitor.visitChildren(self)




    def aconstant(self):

        localctx = reactParser.AconstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_aconstant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            self.scientific()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(reactParser.SymbolContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_rate

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRate" ):
                return visitor.visitRate(self)
            else:
                return visitor.visitChildren(self)




    def rate(self):

        localctx = reactParser.RateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_rate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            self.symbol()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProductsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def product(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(reactParser.ProductContext)
            else:
                return self.getTypedRuleContext(reactParser.ProductContext,i)


        def combineOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(reactParser.CombineOperatorContext)
            else:
                return self.getTypedRuleContext(reactParser.CombineOperatorContext,i)


        def getRuleIndex(self):
            return reactParser.RULE_products

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProducts" ):
                return visitor.visitProducts(self)
            else:
                return visitor.visitChildren(self)




    def products(self):

        localctx = reactParser.ProductsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_products)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.product()
            self.state = 97
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 92
                    self.combineOperator()
                    self.state = 93
                    self.product() 
                self.state = 99
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProductContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(reactParser.SymbolContext,0)


        def scientific(self):
            return self.getTypedRuleContext(reactParser.ScientificContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_product

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProduct" ):
                return visitor.visitProduct(self)
            else:
                return visitor.visitChildren(self)




    def product(self):

        localctx = reactParser.ProductContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_product)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << reactParser.SCIENTIFIC_NUMBER) | (1 << reactParser.PLUS) | (1 << reactParser.MINUS))) != 0):
                self.state = 100
                self.scientific()


            self.state = 103
            self.symbol()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReactantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def reactant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(reactParser.ReactantContext)
            else:
                return self.getTypedRuleContext(reactParser.ReactantContext,i)


        def combineOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(reactParser.CombineOperatorContext)
            else:
                return self.getTypedRuleContext(reactParser.CombineOperatorContext,i)


        def getRuleIndex(self):
            return reactParser.RULE_reactants

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReactants" ):
                return visitor.visitReactants(self)
            else:
                return visitor.visitChildren(self)




    def reactants(self):

        localctx = reactParser.ReactantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_reactants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.reactant()
            self.state = 111
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==reactParser.PLUS:
                self.state = 106
                self.combineOperator()
                self.state = 107
                self.reactant()
                self.state = 113
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReactantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(reactParser.SymbolContext,0)


        def scientific(self):
            return self.getTypedRuleContext(reactParser.ScientificContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_reactant

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReactant" ):
                return visitor.visitReactant(self)
            else:
                return visitor.visitChildren(self)




    def reactant(self):

        localctx = reactParser.ReactantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_reactant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << reactParser.SCIENTIFIC_NUMBER) | (1 << reactParser.PLUS) | (1 << reactParser.MINUS))) != 0):
                self.state = 114
                self.scientific()


            self.state = 117
            self.symbol()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CvalueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scientific(self):
            return self.getTypedRuleContext(reactParser.ScientificContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_cvalue

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCvalue" ):
                return visitor.visitCvalue(self)
            else:
                return visitor.visitChildren(self)




    def cvalue(self):

        localctx = reactParser.CvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_cvalue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.scientific()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol(self):
            return self.getTypedRuleContext(reactParser.SymbolContext,0)


        def EQUAL(self):
            return self.getToken(reactParser.EQUAL, 0)

        def cvalue(self):
            return self.getTypedRuleContext(reactParser.CvalueContext,0)


        def getRuleIndex(self):
            return reactParser.RULE_constant

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant" ):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)




    def constant(self):

        localctx = reactParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.symbol()
            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==reactParser.EQUAL:
                self.state = 122
                self.match(reactParser.EQUAL)
                self.state = 123
                self.cvalue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SymbolContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SYMBOL(self):
            return self.getToken(reactParser.SYMBOL, 0)

        def getRuleIndex(self):
            return reactParser.RULE_symbol

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbol" ):
                return visitor.visitSymbol(self)
            else:
                return visitor.visitChildren(self)




    def symbol(self):

        localctx = reactParser.SymbolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_symbol)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self.match(reactParser.SYMBOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CombineOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(reactParser.PLUS, 0)

        def getRuleIndex(self):
            return reactParser.RULE_combineOperator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCombineOperator" ):
                return visitor.visitCombineOperator(self)
            else:
                return visitor.visitChildren(self)




    def combineOperator(self):

        localctx = reactParser.CombineOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_combineOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.match(reactParser.PLUS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ScientificContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCIENTIFIC_NUMBER(self):
            return self.getToken(reactParser.SCIENTIFIC_NUMBER, 0)

        def PLUS(self):
            return self.getToken(reactParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(reactParser.MINUS, 0)

        def getRuleIndex(self):
            return reactParser.RULE_scientific

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScientific" ):
                return visitor.visitScientific(self)
            else:
                return visitor.visitChildren(self)




    def scientific(self):

        localctx = reactParser.ScientificContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_scientific)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==reactParser.PLUS or _la==reactParser.MINUS:
                self.state = 130
                _la = self._input.LA(1)
                if not(_la==reactParser.PLUS or _la==reactParser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 133
            self.match(reactParser.SCIENTIFIC_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





